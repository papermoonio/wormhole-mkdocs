import * as cfg from './config';
import {
  generateAllChainIdsTable,
  generateAllConsistencyLevelsTable,
  generateAllContractsTable,
  generateProductSupportTables,
  generateTestnetFaucetsTable,
} from './details';
import { generateGovernanceTestnetTable } from './governance';
import { indentBlock } from './util';
import { TagManager } from './tagManager';
import { DOCS_SNIPPETS_DIR } from './env';
import { generateNotionContractTables } from './notion/contractTables';

type ContractModule =
  | 'coreBridge'
  | 'tokenBridge'
  | 'relayer'
  | 'cctp'
  | 'executor'
  | 'tokenBridgeRelayer'
  | 'tokenBridgeRelayerWithReferrer';

async function main() {
  try {
    const [chains, tagManager] = await Promise.all([
      cfg.getDocChains(),
      TagManager.create(DOCS_SNIPPETS_DIR),
    ]);

    const notionTables = await generateNotionContractTables(chains);
    const notionTags = new Set(notionTables.keys());

    const contractTags: Array<{ tag: string; module: ContractModule }> = [
      { tag: 'CORE_ADDRESS', module: 'coreBridge' },
      { tag: 'WTT_ADDRESS', module: 'tokenBridge' },
      { tag: 'RELAYER_BRIDGE_ADDRESS', module: 'relayer' },
      { tag: 'CCTP_ADDRESS', module: 'cctp' },
      { tag: 'EXECUTOR_ADDRESS', module: 'executor' },
      { tag: 'WTT_EXECUTOR_ADDRESS', module: 'tokenBridgeRelayer' },
      {
        tag: 'WTT_EXECUTOR_WITH_REFERRER_ADDRESS',
        module: 'tokenBridgeRelayerWithReferrer',
      },
    ];

    for (const { tag, module } of contractTags) {
      if (notionTables.has(tag)) {
        await tagManager.replace(tag, notionTables.get(tag)!);
        notionTables.delete(tag);
        continue;
      }
      await tagManager.replace(tag, generateAllContractsTable(chains, module));
    }

    for (const [tag, content] of notionTables.entries()) {
      await tagManager.replace(tag, content);
    }

    await tagManager.replace(
      'CONSISTENCY_LEVELS',
      generateAllConsistencyLevelsTable(chains)
    );
    await tagManager.replace(
      'TESTNET_FAUCETS',
      generateTestnetFaucetsTable(chains)
    );
    await tagManager.replace('CHAIN_IDS', generateAllChainIdsTable(chains));

    const productTables = generateProductSupportTables(chains);
    for (const [product, table] of Object.entries(productTables)) {
      const tagSuffix = product === 'tokenBridge' ? 'WTT' : product.toUpperCase();
      await tagManager.replace(`SUPPORTED_BLOCKCHAIN_${tagSuffix}`, table);
    }

    const govTestnetTable = await generateGovernanceTestnetTable();
    await tagManager.replace(
      'GOVERNANCE_TESTNET',
      indentBlock(govTestnetTable, 4)
    );

    const written = await tagManager.commit();
    const modifications = tagManager.getModifications();

    if (notionTags.size > 0) {
      const notionModified = Object.keys(modifications).filter((tag) => notionTags.has(tag));

      if (notionModified.length === 0) {
        console.log('[notion] is up to date.');
      } else {
        console.log(`[notion] updated: ${notionModified.join(', ')}.`);
      }
    }
    if (written.length === 0) {
      console.log('All autogenerated snippets already up to date.');
    } else {
      console.log(`Updated ${written.length} snippet file(s).`);
      for (const [tag, files] of Object.entries(modifications)) {
        console.log(`  ${tag}: ${files.length} file(s)`);
      }
    }
  } catch (err) {
    console.error(err);
    process.exitCode = 1;
  }
}

void main();
